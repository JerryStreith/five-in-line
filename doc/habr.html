<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<title>Five-in-line project</title>
<meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
</head>
<body>

алгоритмы
Поиск решений в логических играх на примере гомоку
гомоку, Treat-Space search, деревья решений

<h4>Вступление</h4>
Вообще речь пойдёт не о классической <a href="http://ru.wikipedia.org/wiki/%D0%93%D0%BE%D0%BC%D0%BE%D0%BA%D1%83">гомоку</a>, а о русской вариации пять в ряд. У вас есть листок бумаги в клеточку, правила такие же как в крестиках-ноликах, только необходимо выстроить линию из 5 элементов.
<img src="http://habrastorage.org/storage3/03e/e96/938/03ee969386d6554e1fd2f60539b11212.png" alt="image"/>
За такой нехитрой игрой мы прослушали не одну лекцию. Меня всегда раздражало, что моя блестящая стратегия разбивается о мою невнимательность. Ну ничего, думал я, вот напишу программу, которая не будет делать ошибок, я тогда всем им покажу! Раз плюнуть! Пару циклов, правда придётся повозится с пользовательским интерфейсом - за пару вечеров управлюсь. С момента окончания института прошло 10 лет, а программу я всё ещё не написал.
<habracut />

<h4>Перебор в лоб</h4>
Идея состоит в том, что у нас нет никакой функции оценки, никакой эвристики - тупо расставляем элементы на поле, пока не достигнем пяти в линию. Сразу становится понятно, что такой метод не годится. Каждый ход в среднем генерирует 80 новых позиций. К 6 ходам количество вариантов возрастает до 80^6= 2^37 вариантов, что неприемлемо много.

<h4>Альфа-бета отсечение</h4>
Альфа-бета отсечение - это то, чем обычно ограничивается курс теории игр в институте. Применяется... честно говоря сложно придумать игру, в которой его можно применить. Возникает идея использовать функцию оценки в качестве критерия стоимости. Проблема в том, что нас по настоящему интересует только победа или поражение. И нас вполне устроит победа за большее число шагов. Отсюда выплывает важное свойство: <b>чтобы доказать победу с определённой позиции, достаточно найти один ход, чтобы доказать поражение - необходимо перебрать все возможные ходы</b>.

<h4>Решение с конца</h4>
Идея состоит в том, чтобы распознавать шаблоны, которые ведут к победе. Аналогия с шахматными программами - база эндшпилей.
<spoiler title="Подобное можно сделать для 5 в ряд">
Игра всегда заканчивается линией из 5 элементов. Если мы вернёмся на шаг назад, получим следующие комбинации:
<img src="http://habrastorage.org/storage3/922/fd9/de8/922fd9de8c6ff833f88ac09a5023786a.png" alt="Шаг до победы"/>

Если вернуться на два шага назад, получим:
<img src="http://habrastorage.org/storage3/c1b/1cf/791/c1b1cf791ddf444d35ec6d4dd24e0480.png" alt="Два шага до победы"/>

Линии можно комбинировать:
<img src="http://habrastorage.org/storage3/34a/d01/232/34ad012322c99cac77d2cc6620794062.png"/>
Весь набор комбинаций можно собрать в дерево поиска, которое разворачивается вокруг точки поиска.
</spoiler>
Такое решение работало медленно. Настолько медленно, что я так и не смог отладить код. Проблема в большом количестве комбинаций.  Два шага назад - это всё, что ещё можно хранить в памяти.

<h4>Вычисление vs хранение</h4>
После такого фейла я решил не хранить готовые шаблоны, а находить линии, за один-два хода до победы "на лету". На удивление это работало довольно неплохо.Вывод: <b>иногда лучше решать, чем хранить</b>.

<h4>В глубину или в ширину</h4>
Поиск в глубину предпочтительнее c точки зрения памяти, но часто уходит слишком глубоко, хотя победа находится рядом в соседней ветке. Поиск в ширину лишён этого недостатка, но требует много памяти для хранения уже решённых позиций. Обыно применяют форсированный поиск в глубину: обычно поиск спускается на фиксированную глубину, но для перспективных позиций глубина увеличивается.


<h4>Оценочная функция</h4>
Скорость поиска очень чувстивтельна к порядку обхода. Для этого вводят функцию, которая оценивает "привлекательность" ходов, сортирует их в порядке привлекательности. 
<spoiler title="Оценочная функция для 5 в ряд ">
Существуют линии, на которые противнику необходимо реагировать.

Открытая четвёрка. Гарантированная победа, если противник не выигрывает на следующем ходу.
<img src="http://habrastorage.org/storage3/95a/72f/763/95a72f7631fac3c4af7916b566126dca.png" alt="image"/>

Закрытая четвёрка. Один ход до победы.
<img src="http://habrastorage.org/storage3/4f4/fd3/083/4f4fd30835f0ef225aeb9bc7ca3a556c.png" alt="image"/>

Открытая тройка. Два хода до победы.
<img src="http://habrastorage.org/storage3/548/075/870/5480758701b9b45b4f9baf40d7826f74.png" alt="image"/>

Приоритет линий в таком порядке. Оценка хода увеличивается, если в одной точке сходятся несколько линий разных направлений. Также учитываются линии противника и защитные ходы на них.
</spoiler>

Работает довольно хорошо. Программа играет на уровне новичка. Это 2 уровня поиска в ширину и 3 уровня форсированного поиска в глубину. К сожалению этого совершенно недостаточно, чтобы выигрывать всегда. На этом идеи у меня закончились и я уже было думал, что ничего существенно улучшить не получится. Если бы я не наткунлся на работу некого <a href="http://en.wikipedia.org/wiki/Victor_Allis">Louis Victor Allis</a>.

<h4>Mr. Allis и Treat-Space search</h4>
В 1992г. мистер Алис, используя 10 рабочих станций SUN SPARC, доказал для классического гомоку с полем 15X15, что крестики всегда побеждают. Станции имели 64 и 128MB RAM, 200MB свопа. Т.к. они использовали станции Vrije Universiteit в Амстердаме, их процессы запускались только ночью. Процессы,  которые не завершились за ночь, на утро убивались. На всё ушло 1000 CPU/часов и неделя времени.

<spoiler title="Как же, чёрт возьми, ему это удалось? ">

Немного теории из оригинальной статьи. Гомоку - это рассходящаяся игра с полной информацией и внезапной смертью.
<ul>
<li>Расходящаяся (<i>diverging</i>) означает, что количество возможных позиций растёт с у величением числа фигур на доске.</li>
<li>Полная информация (<i>perfect-information</i>) означает, что обоим противникам целиком всё известно о текущем состоянии игры. Примеры игр с полной информацией: шашки, шахматы. Примеры игр с неполной информацией (<i>imperfect-information</i>) дурак, преферанс.</li>
<li>Внезапная смерть (<i>sudden death</i>) означает, что игра может внезапно закончится, когда ещё есть фигуры на доске или есть свободное пространство. Шахматы - пример игры с внезапной смертью. Игра, где этого не происходит - шашки.</li>
</ul>
Верхняя граница количества состояний (<i>state-space complexity</i>) 3<sup>225</sup> ~= 10<sup>105</sup>. 10<sup>70</sup> - сложность дерева решений (<i>game-tree complexity</i>), при предположении, что в среднем игра длится 30 ходов и имеет <i>225 - i</i> возможных ходов на <i>i-ом</i> ходу.
Наблюдая за профессиональными игроками, он сделал вывод, что человек в первую очередь ищет цепочку уроз (<i>threat sequence</i>), которая может привести к победе. При этом ответные ходы противника практически полностью игнорируются. Только если подходящая цепочка найдена, проверяется возможность контратаки.
На этом факте и построена эвристика Treat-Space search. Для каждой атакующей линии с клеткой атаки (<i>gain</i>), которая базируется на уже существующих ходах (<i>rest squares</i>), мы отвечаем <b>сразу всеми</b> защитными ходами (<i>cost squares</i>). После этого проверяем, возможно ли ещё построить цепочку угроз, которая ведёт к победе.

<img src="http://habrastorage.org/storage3/298/032/0c5/2980320c5827f968d98b0a22abf117c8.png"/>
<i>Начало цепочки угроз и её развитие</i>

<img src="http://habrastorage.org/storage3/136/2e5/183/1362e518374d2814726b0e85cd4e9e86.png"/>
<i>Анализ цепочки угроз. На первую угрозу, отвечаем сразу тремя защитными ходами. Несмотря на ответные ходы, возможно построение открытой четвёрки.</i>

Такая эвристика возволяет нам эффективно искать цепочки угроз, на которые противник уже не в состоянии  повлиять. Ответ одновременно всеми защитными ходами, позволяет сделать поиск практически линейным, вместо комбинаторного. Конечно, каждую цепочку необходимо проверять на возможность контратак.
</spoiler>

К сожалению, как проверять цепочки на возможность контратаки, <s>я нифига не понял</s> автор не уточнил. Поэтому пришлось лепить своё решение на коленке. На данный момент это самое медленное и стрёмное место в расчёте.

<h4>Эвристика нулевого хода</h4>
Лучше всего описана <a href="http://frayn.net/beowulf/theory.html#nullmove">здесь</a>.
Идея сводится к тому, что вы пропускаете свой ход, позволяя противнику сделать ход. Если ваша позиция всё ещё остаётся сильной, то вероятно это не то состояние, в которое противник позволит вам попасть. Это позволяет сэкономить один ход в глубину при анализе.

К сожалению, я не придумал как это безопасно и эффективно применить, поэтому пока не применяю.

<h4>Крестики выигрывают и дерево решений</h4>
С Treat-Space search эвристикой программа играет довольно сильно, но всё равно проигрывает сильному игроку. Это происходит потому, что программа способна "видеть" на 4 - 16 ходов вперёд. Иногда, особенно вначале партии, выгоднее ставить ходы на перспективу, а не пытаться развить локальное преимущество. Человек использует свой опыт, чтобы видеть направления, которые дадут преимущество в далёкой перспективе.
Так мы подходим к ещё одной проблеме компьютерных программ - недостаток опыта (<i>lack of experience</i>). Чтобы компенсировать это, в шахматных программах используется база дебютов. Можно подобдное сделать и для пять в ряд. Проблема в том, <s>что теорию гомоку я не осилил</s> что теория для этой игры не так хорошо проработана, как для шахмат.

Поэтому возникает естественное желание перебрать дерево решений целиком, чтобы найти лучшие ходы. Как бонус можно получить доказательство, что крестики выигрывают, и оптимальную последовательность как бонус. Собственно это и сделал профессор Allis в своём исследовании. Согласно теории поле 19X19 даёт крестикам большее преимущество, чем 15X15, поэтому для неограниченного поля должно быть ещё легче.


<h4>Распределённые вычисления на коленке</h4>
Сразу становится понятно, что на одной машине такое не посчитать. С другой стороны, задача очень хорошо параллелится.
<spoiler title="Значит, надо подымать инфраструктуру для распределённых вычислений.">
Быстренько слепил сервер на основе nginx, php-fastcgi, wget, скриптов и моих прог. 
Пришлось повозится с базой, т.к. база предполагалась очень большая и доступ к элементам происходит очень часто. У меня был большой опыт с PostgreSQL, но она меня не устроила, т.к. даже если данные умещаются в тоже место на диске, СУБД всё равно размещает их в конце таблицы, из-за транзакционности. Таким образом, если один элемент апдейтится часто, то таблица быстро распухает. Надо её вакумить, а на нагруженном сервере это проблематично. Вместо этого я родил свой велосипед, в котором в качестве базы использовался микс из AVL-дерева и структуры каталогов. Когда дерево превышает некий предел, оно разделяется на два в разных директориях. Получается такое себе хешодерево. На практике получилось плохое решение. Во первых AVL дерево - неудачное дерево, для работы с диском. В момент разделения данные поступают в новое дерево в сортированном порядке - это худший вариант для балансировки. Во вторых , практика показала, что аккумулировать такое количество ресурсов, чтобы база стала узким местом, довольно проблематично, и PostgeSQL меня бы целиком устроил.
В качестве нод, я планировал использовать "дешёвые" облачные сервисы. Я использовал Scalaxy, и Amazon. Внезапно я осознал, что <b>вычисления стоят реальных денег</b>. Scalaxy давал 16 ядер на сервер, это обходилось мне, кажется, в 10$/сутки. При этом 16 процессов работали как-то очень натужно. На амазоне я пытался пускать 2 инстанса по 8 ядер и это стоило тоже вполне существенные деньги. Также я пытался взять количеством, пустить 50 микроинстансов, это обошлось мне 40$ в сутки. По ощущениям работали они хуже, чем 2 сервака по 8 ядер. Это заставило меня задуматься, сколько же в действительности стоят вычисления. На тот момент, мне требовалось 10000 ядер. Допустим, железо нам досталось бесплатно. Допустим, у нас 2-х процессорные 8-ядерные Xeon, с гипертриденгом. Итого нам требуется 10000/(2*8*2)=312.5 серверов. Допустим такой сервер жрёт 200Вт. Итого в сутки нам надо оплатить 312.5*200Вт*24ч=1.5МВт*ч *0.11875$/(Квт/ч)= 178.125$/сутки.
Поэтому я <s>захотел получить вычислительные ресурсы на шару</s> обратился к свободному интернет сообществу. Год назад, благодаря <a href="http://rsdn.ru/forum/alg/4851738">сообществу RSDN</a>, стартовал пробный запуск.
Согласно теории, к-во вариантов сначала расширяется, потом начинает сужаться за счёт отсечения решённых веток. Считалась позиция с 7 хода. Расчёт был на то, что к 8 ходу рост числа вариантов если хотя бы не уменьшится, то хотя бы замедлится скорость роста.
</spoiler>

Расчёт продлился около месяца. К сожалению, чуда не произошло. К-во вариантов стабильно росло. Расчёт пришлось остановить. Даже на состояниях с 17-35 ходами, дерево решений также стабильно расширяется.
Причина этого кроется в поиске в ширину. Мы затевали поиск в ширину, чтобы найти неочевидные решения. Для этого приходится обходить все варианты, даже самые идиотские.
<img src="http://habrastorage.org/storage3/2ea/320/fa1/2ea320fa171fd574009e4813acf21aa6.png"/>


<h4>Алгоритм муравьиной колонии</h4>
Идеи у меня закончились, проект я забросил почти на год. Пока мой коллега не предложил мне использовать <a href="http://en.wikipedia.org/wiki/Ant_colony_optimization_algorithms">алгоритм муравьиной колонии</a>.
Идея состоит в том, что мы случайным образом выбираем путь, который мы будет исследовать с определённого состояния. Вероятность хода зависит от соотношения числа побед\поражений всех потомков данной ветки.
Работает довольно неплохо. Проблема только в том, что нас не интересует насколько вероятен проигрыш противника, если есть хотя бы одна позиция, в которой он может выиграть.
<img src="http://habrastorage.org/storage3/72b/e70/b0c/72be70b0c4493bd068761764aaf62a29.png"/>


<h4>Спроси соседа про победу</h4>
<h4>База дебютов и человек</h4>
<h4>А давайте перепишем на ассемблер</h4>
<h4>Благодарности</h4>
<h4>Ссылки и литература</h4>
http://frayn.net/beowulf/theory.html
http://www-public.it-sudparis.eu/~gibson/Teaching/CSC4504/ReadingMaterial/KnuthMoore75.pdf
Allis, L. V. (1994). Searching for solutions in games and artificial intelligence, Ph.D. Thesis, University of Limburg, Maastricht.
Allis, L. V., Herik, H. J. van den, and Huntjens, M. P. H. (1996). Go-Moku Solved by New Search Techniques. Computational Intelligence, Vol. 12.
http://habrahabr.ru/post/111210/
http://habrahabr.ru/post/143552/

</body>
</html>
