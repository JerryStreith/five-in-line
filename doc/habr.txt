алгоритмы
Поиск решений в логических играх на примере гомоку
гомоку, Treat-Space search, деревья решений

<h4>Вступление</h4>
Вообще речь пойдёт не о классической гомоку, а о русской вариации пять в ряд. У вас есть листок бумаги в клеточку, правила такие же как в крестиках-ноликах, только необходимо выстроить линию из 5 элементов.
<img src="http://habrastorage.org/storage3/03e/e96/938/03ee969386d6554e1fd2f60539b11212.png" alt="image"/>
За такой нехитрой игрой мы прослушали не одну лекцию. Меня всегда раздражало, что моя блестящая стратегия разбивается о мою невнимательность. Ну ничего, думал я, вот напишу программу, которая не будет делать ошибок, я тогда всем им покажу! Раз плюнуть! Пару циклов, правда придётся повозится с пользовательским интерфейсом - за пару вечеров управлюсь. С момента окончания института прошло 10 лет, а программу я всё ещё не написал.
<habracut />

<h4>Перебор в лоб</h4>
Идея состоит в том, что у нас нет никакой функции оценки, никакой эвристики - тупо расставляем элементы на поле, пока не достигнем пяти в линию. Сразу становится понятно, что такой метод не годится. Каждый ход в среднем генерирует 80 новых позиций. К 6 ходам количество вариантов возрастает до 80^6= 2^37 вариантов, что неприемлемо много.

<h4>Альфа-бета отсечение</h4>
Альфа-бета отсечение - это то, чем обычно ограничивается курс теории игр в институте. Применяется... честно говоря сложно придумать игру, в которой его можно применить. Возникает идея использовать функцию оценки в качестве критерия стоимости. Проблема в том, что нас по настоящему интересует только победа или поражение. И нас вполне устроит победа за большее число шагов. Отсюда выплывает важное свойство: <b>чтобы доказать победу с определённой позиции, достаточно найти один ход, чтобы доказать поражение - необходимо перебрать все возможные ходы</b>.

<h4>Решение с конца</h4>
Идея состоит в том, чтобы распознавать шаблоны, которые ведут к победе. Аналогия с шахматными программами - база эндшпилей.
<spoiler title="Подобное можно сделать для 5 в ряд">
Игра всегда заканчивается линией из 5 элементов. Если мы вернёмся на шаг назад, получим следующие комбинации:
<img src="http://habrastorage.org/storage3/922/fd9/de8/922fd9de8c6ff833f88ac09a5023786a.png" alt="Шаг до победы"/>

Если вернуться на два шага назад, получим:
<img src="http://habrastorage.org/storage3/c1b/1cf/791/c1b1cf791ddf444d35ec6d4dd24e0480.png" alt="Два шага до победы"/>

Линии можно комбинировать:
<img src="http://habrastorage.org/storage3/34a/d01/232/34ad012322c99cac77d2cc6620794062.png"/>
Весь набор комбинаций можно собрать в дерево поиска, которое разворачивается вокруг точки поиска.
</spoiler>
Такое решение работало медленно. Настолько медленно, что я так и не смог отладить код. Проблема в большом количестве комбинаций.  Два шага назад - это всё, что ещё можно хранить в памяти.

<h4>Вычисление vs хранение</h4>
После такого фейла я решил не хранить готовые шаблоны, а находить линии, за один-два хода до победы "на лету". На удивление это работало довольно неплохо.Вывод: <b>иногда лучше решать, чем хранить</b>.

<h4>В глубину или в ширину</h4>
Поиск в глубину предпочтительнее c точки зрения памяти, но часто уходит слишком глубоко, хотя победа находится рядом в соседней ветке. Поиск в ширину лишён этого недостатка, но требует много памяти для хранения уже решённых позиций. Обыно применяют форсированный поиск в глубину: обычно поиск спускается на фиксированную глубину, но для перспективных позиций глубина увеличивается.


<h4>Оценочная функция</h4>
Скорость поиска очень чувстивтельна к порядку обхода. Для этого вводят функцию, которая оценивает "привлекательность" ходов, сортирует их в порядке привлекательности. 
<spoiler title="Оценочная функция для 5 в ряд ">
Существуют линии, на которые противнику необходимо реагировать.

Открытая четвёрка. Гарантированная победа, если противник не выигрывает на следующем ходу.
<img src="http://habrastorage.org/storage3/95a/72f/763/95a72f7631fac3c4af7916b566126dca.png" alt="image"/>

Закрытая четвёрка. Один ход до победы.
<img src="http://habrastorage.org/storage3/4f4/fd3/083/4f4fd30835f0ef225aeb9bc7ca3a556c.png" alt="image"/>

Открытая тройка. Два хода до победы.
<img src="http://habrastorage.org/storage3/548/075/870/5480758701b9b45b4f9baf40d7826f74.png" alt="image"/>

Приоритет линий в таком порядке. Оценка хода увеличивается, если в одной точке сходятся несколько линий разных направлений. Также учитываются линии противника и защитные ходы на них.
</spoiler>

Работает довольно хорошо. Программа играет на уровне новичка. Это 2 уровня поиска в ширину и 3 уровня форсированного поиска в глубину. К сожалению этого совершенно недостаточно, чтобы выигрывать всегда. На этом идеи у меня закончились и я уже было думал, что ничего существенно улучшить не получится. Если бы я не наткунлся на работу некого Louis Victor Allis.

<h4>Mr. Allis и Treat-Space search</h4>
<h4>Эвристика нулевого хода</h4>
<h4>Крестики выигрывают и дерево решений</h4>
<h4>Муравьиный алгоритм</h4>
<h4>Neighbour win hint</h4>
<h4>База дебютов и человек</h4>
<h4>Распределённые вычисления на коленке</h4>
<h4>А давайте перепишем на ассемблер</h4>
<h4>Литература</h4>
http://ru.wikipedia.org/wiki/%D0%93%D0%BE%D0%BC%D0%BE%D0%BA%D1%83
http://www-public.it-sudparis.eu/~gibson/Teaching/CSC4504/ReadingMaterial/KnuthMoore75.pdf
Allis, L. V. (1994). Searching for solutions in games and artificial intelligence, Ph.D. Thesis, University of Limburg, Maastricht.
Allis, L. V., Herik, H. J. van den, and Huntjens, M. P. H. (1996). Go-Moku Solved by New Search Techniques. Computational Intelligence, Vol. 12.
http://habrahabr.ru/post/111210/
http://habrahabr.ru/post/143552/